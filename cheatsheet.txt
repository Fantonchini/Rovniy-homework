mkdir name - создание пустого каталога с именем name
ls - показывает что находится в текущем каталоге
cd name - переход в каталог name(если он внутри текущего каталога)
touch name.ext - создание файла с именем name и расширением ext
git init - создать репозиторий (внутри текущего каталога)
git add name.ext - добавление в репозиторий файла name.ext(индексируются изменения, а не файл целиком)
git commit -m 'first commit' - сделать коммит добавленных файлов с комментарием first commit
(если указать коммит без флага -m, появится редактор комментариев. Вводим комментарий в первой строке, затем ESC и :wq
git status - проверка текущего состояния репозитория
(changes not staged for commit: изменения в репозитории не зафиксированы)
Чтобы отменить изменения, используется git checkout name.ext
(changes to be commited: изменения проиндексированы(готовы к коммиту))
Чтобы не коммитить изменения, используется git reset
git log - список произведенных изменений (коммиты)
для лога есть всякие клевые штуки:

--pretty="..." - определяет формат вывода
%h - укороченный хэш коммита
%d - дополнения коммита ("головы" веток или теги)
%ad - дата коммита
%s - комментарий
%an - имя автора
--graph - отображение дерева коммитов в виде ascii-графика
--date=short - короткий формат вывода даты (yyyy-mm-dd)

в Windows есть файл с настройками git config (C:\users\username), где сохранены настройки для текущего пользователя. Туда сохраняются алиасы.
git config --global alias.AL command - создание алиаса с именем AL и содержимым command

git checkout <hash> - копирует снимок из репозитория в рабочий каталог (история с изменениями) <hash> - хэш коммита (первые 7 символов)
git checkout master - вернуться к последней версии в ветке master
!Переключая имена веток, переключение идет на последнию версию выбранной ветки
cat file.ext - просмотр содержимого файла file.ext
git tag name - создать тег с именем name для текущей версии файлов(коммита)
git checkout name^ - переключиться на родителя тега name (версия перед версией с тегом name)
После добавления тегов можно переключаться между версиями с тегами через checkout name, где name - имя тега
git tag - список доступных тегов
в логах эти теги будут видны(HEAD указывает на то, на какой версии мы в данный момент)
если мы сделали изменения в файле name.ext и хотим их отменить(вернуться к последней сохраненной версии) - используем git checkout name.ext
git reset HEAD name.ext - сброс проиндексированной зоны к HEAD (изменения всё еще есть)
Чтобы отменить коммит, нужно сделать коммит, отменяющий коммит:
git revert HEAD - отменить коммит, где был HEAD (в логах сохранится и коммит и его отмена)
Чтобы удалить коммиты из ветки, необходимо сделать команду:
git reset --hard <hash>|tag - сброс выполнится на указанный хэш или тег коммита(этот коммит станет последним актуальным)
!Сами коммиты никуда не удаляются, они просто отсутствуют в ветке, и сослаться на них можно лишь по тегам или хешам. Коммиты остаются в репозитории до тех пор, пока не будет запущен сборщик мусора
Если у удаленных из ветки коммитов есть тег, то можно удалить его из репозитория:
git tag -d tagname - удаляет коммиты с тегом tagname
Чтобы изменить сделанный коммит(вместо сброса и создания нового коммита) можно сделать следующее:
1. делаем коммит(понимаем, что нужно было что-то другое сделать)
2. делаем изменения
3. выполняем коммит с параметром --amend и новым комментом коммита:
git commit --amend -m 'new comment'
коммит заменится коммитом с новыми изменениями и комментарием.
git mv name.ext directory - перемещение файла name.ext в каталог directory ВНУТРИ текущего каталога

Каталог .git, содержащийся внутри репозитория содержит много полезного:
1. .git/objects - база данных объектов. в базе содержатся каталоги из 2 символов. Их имена - первые две буквы хэша sha1 объекта, хранящегося в git.
Внутри каталога файлы, содержащие объекты, хранящиеся в git. Они сжаты и закодированы.
2. .git/config - файл конфигурации, создающийся для каждого конкретного проекта. Записи файла перезаписывают настройки файла .gitconfig в рамках этого проекта
3. .git/refs - внутри каталоги веток (heads) и тегов (tags)
4. .git/refs/heads - список веток. Содержимое ветки - хеш коммита
5. .git/refs/tags - список тегов. Содержимое тега - хеш коммита
6. .git/HEAD - ссылка на текущую ветку

git cat-file -t <hash> - вывод типа объекта по хэшу (коммит, дерево, блоб)
git cat-file -p <hash> - вывод объекта коммита по хэшу (выводит хэш дерева, хэш родителя, автора, автора коммита, комментарий)
git cat-file -p <treehash> - вывод дерева из файлов(блоб) и каталогов(tree) с их хэшами
git cat-file -p <file> - вывод содержимого файла

Чтобы начать работать в новой ветке, необходимо:
1. git branch branchname - создать новую ветку с именем branchname
2. git checkout branchname - выбрать созданную ранее ветку с именем branchname
или сделать так:
git checkout -b branchname

отображение всех веток и их коммитов:
bit branch - список веток
git log --all (--graph добавит графические ветки)
Слияние веток:
1. git checkout branch1 - выбрать ветку, в которую будем копировать изменения
2. git merge branch2 - произвести слияние ветки branch2 в branch1
Теперь все, что менялось в branch2, будет и в branch1
Во время слияния могут возникать конфликты
Во время выполнения merge в branch1 могут быть файлы с кодом, конфликтующим с этими же файлами и их кодом в branch2:
<<<<<<< HEAD
    code1
=======
    code2
>>>>>>> master
Сверху в текущей ветке есть код, снизу в ветки, с которой сливаемся, есть код в том же месте, они не заменяются друг другом сами.
Чтобы решить конфликт, надо в версии файла текущей ветки сделать соответствующие изменения(оставить код сверху или снизу), затем проиндексировать и закоммитить измененные файлы.

Перебазирование: аналог слияния, но дерево коммитов отличается. Дерево коммитов первой ветки переписывается таким образом, что вторая ветка является частью истории коммитов.
git checkout branch1
git rebase branch2
Перебазирование лучше не использовать, если:
1. ветка является публичной и расшаренной
2. важна точная история коммитов ветки
Лучше использовать перебазирование для кратковременных, локальных веток

git clone directory new_directory - создание клона репозитория directory с именем new_directory
Теперь репозиторий directory считается удаленным(от слова далеко, а не удалить) для репозитория new_directory
git remote - узнать имя удаленного репозитория
git remote show reponame - показать подробную информацию об удаленном репозитории по имени reponame:
1. Ссылка на репозиторий
2. Список веток
обычно имя по умолчанию - origin
В локальном репозитории будет существовать только основная локальная ветка по умолчанию. В удаленном репозитории ветки не рассматриваются как локальные. Чтобы увидеть ветки удаленного репозитория, надо ввести git branch -a
git fetch - команда, которая извлекает новые коммиты из удаленного репозитория, но не сливает их с наработками в локальных ветках. (После fetch метка HEAD находится на последнем рабочем коммите локальной ветки)
Чтобы слить изменения, пользуемся git merge branchname 
Есть более удобный способ, позволяющий объединить команды git fetch и git merge:
git pull
Можно добавить локальную ветку, которая отслеживает изменения удаленной ветки:
git branch --track branchname remotebranch - создается локальная ветка branchname, которая будет следить за remotebranch

Чистый репозиторий - репозиторий, который используется для расшаривания (не хранит служебные данные в директории .git:
bit clone --bare hello hello.git - создание чистого репозитория
git remote add remotename URL - добавить к репозиторию в текущем каталоге удаленный репозиторий по ссылке URL с именем remotename
Чтобы отправить изменения локального репозитория в удаленный, используется команда push:
git push remotename branch - отправит все коммиты в удаленный репозитой с именем remotename в ветку branch